# 比特、字节、整型

## 数字信号的优点

    用一个电压范围表示一个数字信号，因此人如果电路中存在噪音、干扰或其他不完善的地方，只要不超过设定的阈值，你就会得到一个很清晰的信号

## C的数据表示

<img src="https://cdn.jsdelivr.net/gh/sesns/picgo_bed/cmu15213_2.1.png" title="" alt="" data-align="center">

## 位运算

<img src="https://cdn.jsdelivr.net/gh/sesns/picgo_bed/cmu15213_2.2.png" title="" alt="" data-align="center"><img src="https://cdn.jsdelivr.net/gh/sesns/picgo_bed/cmu15213_2.3.png" title="" alt="" data-align="center">

## 二进制与集合

#### 一.用二进制表示集合

    例如，用8位二进制数表示集合{0,1,2,3,4,5,6,7}的子集

<img src="https://cdn.jsdelivr.net/gh/sesns/picgo_bed/cmu15213_2.4.png" title="" alt="" data-align="center">

#### 二.用二进制数表示集合时运算符的含义

    用二进制数表示集合，那么对两个表示集合的二进制运算有着新的含义

- & 表示集合的交运算

- |表示集合的并运算

- ~表示集合的补集运算

- ^表示集合的对称差异
  
  - 两个集合的对称差是只属于其中一个集合，而不属于另一个集合的元素组成的集合，例如集合{1,2,3} 和{3,4} 的对称差为{1,2,4}

## C中的一些运算符

#### 一.位运算符

    & | ~ ^

#### 二.逻辑运算符

    && || ! 

#### 三.左移、右移运算符

- 左移运算符
  
  - 用0来填充右侧

- 右移运算符
  
  - 逻辑右移运算符
    
    - 用0来填充左侧
  
  - 算术右移运算符
    
    - 符号位向右移动后,正数的话补0,负数补1,也就是汇编语言中的算术右移.

## 编码

#### 一.原码、反码、补码引入原因

- 冯·诺依曼体系结构中运算器只有加法运算器，没有减法运算器，原因是减法运算器硬件开销太大，被废除了

- 计算机中没办法直接做减法的，它的减法是通过加法实现的。现实世界中所有的减法也可以当成加法的，减去一个数可以看作加上这个数的相反数，但前提是要先有负数的概念，这就是为什么不得不引入一个符号位。

- **原码、反码、补码的产生过程就是为了解决计算机做减法和引入符号位的问题**

#### 二.原码

###### 1.概念

    是最简单的机器数表示法，用最高位表示符号位，其他位存放该数的二进制的绝对值

    以带符号位的四位二进制数为例：1010，最高位为1表示这是一个负数，其它三位010，即0\*2^2+1\*2^1+0\*2^0=2，所以1010表示十进制数-2。

<img src="https://cdn.jsdelivr.net/gh/sesns/picgo_bed/clipboard.png" title="" alt="" data-align="center">

###### 2.缺点

    原码的表示法很简单，虽然出现了+0和-0，但是直观易懂。于是开始运算会看到

```
0001+0010=0011，1+2=3；
0000+1000=1000，+0+(-0)=-0；
0001+1001=1010，1+(-1)=-2。
```

    于是可以看到其实正数之间的加法通常是不会出错的，因为它就是一个很简单的二进制加法，**而正数与负数相加，或负数与负数相加，就要引起莫名其妙的结果，这都是符号位引起的。0分为+0和-0也是因它而起。**

###### 3.特点

- 原码表示直观、易懂，与真值转换容易。

- 原码中0有两种不同的表示形式，给使用带来了不便。

> 通常0的原码用+0表示，若在计算过程中出现了-0，则需要用硬件将-0变成+0。

- 原码表示加减运算复杂。

> 利用原码进行两数相加运算时，首先要判别两数符号，若同号则做加法，若异号则做减法。在利用原码进行两数相减运算时，不仅要判别两数符号，使得同号相减，异号相加；还要判别两数绝对值的大小，用绝对值大的数减去绝对值小的数，取绝对值大的数的符号为结果的符号。可见，原码表示不便于实现加减运算。

#### 三.反码

###### 1.概念

    正数的反码还是等于原码；负数的反码就是它的原码除符号位外，按位取反。

    以带符号位的四位二进制数为例：3是正数，反码与原码相同，则可以表示为0011；-3的原码是1011，符号位保持不变，低三位按位取反，所以-3的反码为1100。

<img src="https://cdn.jsdelivr.net/gh/sesns/picgo_bed/cliphhhboard.png" title="" alt="" data-align="center">

###### 2.特点

- 在反码表示中，数值0有两种表示方法。
- 反码的表示范围与原码的表示范围相同。

#### 四.补码

###### 1.概念

    如果说现在时针现在停在10点钟，那么什么时候会停在八点钟呢？

> 简单，过去隔两个小时的时候是八点钟，未来过十个小时的时候也是八点钟。 也就是说时间倒拨2小时，或正拨10小时都是八点钟。 也就是10-2=8，而且10+10=8。 这个时候满12，说明时针在走第二圈，又走了8小时，所以时针正好又停在八点钟。

> 所以12在时钟运算中，称之为模，超过了12就会重新从1开始算了。

> 也就是说，10-2和10+10从另一个角度来看是等效的，它都使时针指向了八点钟。

    既然是等效的，那么在时钟运算中，减去一个数，其实就相当于加上另外一个数（这个数与减数相加正好等于12，也称为同余数），我们称该同余数为原值的补码。

    **正数补码=它的原码**

    **负数补码=同余数=模-负数绝对值=反码+1**   

    **对于数值有限制、有溢出的运算（模运算）来说，减去一个数，其实也相当于加上这个数的同余数。也就是说，不引入负数的概念，就可以把减法当成加法来算。**

###### 2.特点

- 在补码表示中，用符号位表示数值的正负，形式与原码的表示相同，即0为正，1为负。但补码的符号可以看做是数值的一部分参加运算。

> 正数的补码表示就是其本身，负数的补码表示的实质是把负数映像到正值区域，因此加上一个负数或减去一个正数可以用加上另一个数（负数或减数对应的补码）来代替。

> 从补码表示的符号看，补码中符号位的值代表了数的正确符号，0表示正数，1表示负数；而从映像值来看，符号位的值是映像值的一个数位，因此在补码运算中，符号位可以与数值位一起参加运算。

- 在补码表示中，数值0只有一种表示方法，在补码中也不存在-0了，因为1000表示-8。

- **由于补码表示中的符号位可以与数值位一起参加运算，并且可以将减法转换为加法进行运算，简化了运算过程，因此计算机中均采用补码进行加减运算。**

- 为什么负数的补码的求法是反码+1

> 负数的反码+负数绝对值+1=二进制数的模

> 负数的反码+1=二进制数的模-负数绝对值=负数绝对值的同余数=负数的补码

#### 五.转换

###### 1.二进制数转换为无符号数

![](https://cdn.jsdelivr.net/gh/sesns/picgo_bed/clipboaxrd.png)

###### 2.二进制数转换为补码

![](https://cdn.jsdelivr.net/gh/sesns/picgo_bed/cmu15213_2.5.png)
